package {	import flash.display.Sprite;	import flash.display.Shape;	import flash.net.*;	import flash.events.*;    import flash.display.Graphics;	import flash.xml.XMLDocument;	import flash.xml.XMLNode;    import MapPoint;	public class FlxerDrawerPlugIn extends Sprite {		var drawer_lc_receive;		var shapesAcnt,shapesA,cntMask,drawCnt,drawArea;		var handlesAcnt;		var handles;		public var currentShape		var flxerDrawer_lc_controller;		var flxerDrawer_lc_plugin;		public static var w:uint;		public static var h:uint;		var trgtEdit, trgtUse;		/* DEBUG */		var Plugin		public function FlxerDrawerPlugIn() {			var ch = 0;			/*trace("getMovie "+Plugin.getMovie(ch));			trace("getChannel "+Plugin.getChannel(ch).parent.parent);			trace("getMask "+Plugin.getMask(ch));			trace("getCurrentChannel "+Plugin.getCurrentChannel());			trace("getMonWidth "+Plugin.getMonWidth());			trace("getMonHeight "+Plugin.getMonHeight());			*/			flxerDrawer_lc_controller = new LocalConnection();			flxerDrawer_lc_controller.client = this;			flxerDrawer_lc_plugin = new LocalConnection();            try {				flxerDrawer_lc_controller.connect("receive_from_controller");            } catch (error:ArgumentError) {                trace("Can't connect...the connection name is already being used by another SWF");            }			/* DEBUG 			trgtEdit = this;			avvia(null)*/		}		public function avvia(p):void {			/* DEBUG */			Plugin = p			trgtEdit = Plugin.getMonitor();			w = Plugin.getMonWidth();			h = Plugin.getMonHeight();			trace("cazzo"+w)			trace("cazzo"+h)			if (trgtEdit.getChildByName("drawCnt")) {				drawCnt = trgtEdit.getChildByName("drawCnt")				drawArea = trgtEdit.getChildByName("drawArea")			} else {				drawArea = new Sprite();				drawArea.name = "drawArea";				drawArea.x = w/2;				drawArea.y = h/2;				var shape = new Sprite();				shape.graphics.beginFill(0xFFFFFF,.5);				shape.graphics.moveTo(-w/2,-h/2);				shape.graphics.lineTo(w/2,-h/2);				shape.graphics.lineTo(w/2,h/2);				shape.graphics.lineTo(-w/2,h/2);				shape.graphics.lineTo(-w/2,-h/2);				shape.graphics.endFill();				drawArea.addChild(shape);				drawArea.addEventListener(MouseEvent.MOUSE_DOWN, myMouseDown);				drawArea.addEventListener(MouseEvent.MOUSE_UP, myMouseUp);				trgtEdit.addChild(drawArea);				//				drawCnt = new Sprite();				drawCnt.name = "drawCnt";				drawCnt.x = w/2;				drawCnt.y = h/2;				handles = new Sprite();				drawCnt.addChild(handles);				trgtEdit.addChild(drawCnt);			}			shapesA = new Array();			shapesAcnt = new Array();			handlesAcnt = new Array();		}		/* EDITING */		public function newShape():void {			trace("newShapennnnnnnnnnnn");			currentShape = undefined		}		public function clearEdit():void {			for (var a=0;a<shapesA.length;a++) {				for (var b=0;b<shapesA[a].length;b++) {					trace("clearEditclearEditclearEditclearEditclearEditclearEdit")					if (trgtEdit.contains(drawArea)) handlesAcnt[a].removeChildAt(0);					shapesAcnt[a].graphics.clear();				}			}			shapesA = new Array();			shapesAcnt = new Array();			handlesAcnt = new Array();			currentShape = undefined			trace("clearEditnnnnnnnnnn");		}		public function saveShapes():void {			trace("saveShapesnnnnnnnnnn");			var xmlTmp = "<g>\n";			for (var a=0;a<shapesA.length;a++) {				xmlTmp+="	<path fill='#000000' stroke='none' d='M"+shapesA[a][0][2]+","+shapesA[a][0][3];				for (var b=1;b<shapesA[a].length;b++) {					trace("gggg "+a+" "+b)					xmlTmp+="Q"+shapesA[a][b][0];					xmlTmp+=","+shapesA[a][b][1];					xmlTmp+=","+shapesA[a][b][2];					xmlTmp+=","+shapesA[a][b][3];				}				xmlTmp+="Q"+shapesA[a][0][0];				xmlTmp+=","+shapesA[a][0][1];				xmlTmp+=","+shapesA[a][0][2];				xmlTmp+=","+shapesA[a][0][3];				xmlTmp+="' />\n";			}			xmlTmp+="</g>\n";			flxerDrawer_lc_plugin.send("receive_from_plugin", "saveShapesAct", xmlTmp);		}		private function myMouseDown(event:Event):void {			//drawArea.removeEventListener(MouseEvent.MOUSE_DOWN, myMouseDown);			trace("cazzocazzocazzo2 "+shapesA.length)			if (currentShape == undefined) {				shapesA.push(new Array());				currentShape = shapesA.length-1;				//				shapesAcnt.push(new Sprite());				handlesAcnt.push(new Sprite());				drawCnt.addChild(shapesAcnt[currentShape]);				drawCnt.addChild(handlesAcnt[currentShape]);				/*if (!Preferences.pref.flxerDrawedMasks.data.lista) {					Preferences.pref.flxerDrawedMasks.data.lista = new Array();				}*/			}			trace("cazzocazzocazzo3 "+currentShape);			var p = new Array(drawCnt.mouseX,drawCnt.mouseY,drawCnt.mouseX,drawCnt.mouseY);			shapesA[currentShape].push(p);			handlesAcnt[currentShape].addChildAt(new MapPoint(p,currentShape,shapesA[currentShape].length-1, updatePath, true),shapesA[currentShape].length-1);			updateCurrent();		}		private function updatePath(shape,id,a,b,c,d) {			currentShape = shape;			trace("shape "+shape)			trace("id "+id)			shapesA[shape][id][0] = a;			shapesA[shape][id][1] = b;			shapesA[shape][id][2] = c;			shapesA[shape][id][3] = d;			updateCurrent();			if (id==0) currentShape = undefined;		}		/**/		private function myMouseUp(event:Event):void {			drawArea.addEventListener(MouseEvent.MOUSE_DOWN, myMouseDown);			//handles.getChildAt(shapesA[currentShape].length-1);		}		public function getMonWidth() {			return Plugin.getMonWidth();		}		public function getMonHeight() {			return Plugin.getMonHeight();		}		public function setUseMap() {			if (trgtEdit.contains(drawArea)) trgtEdit.removeChild(drawArea);			if (trgtEdit.contains(drawCnt)) trgtEdit.removeChild(drawCnt);		}		public function setEditMap() {			trace("editMapeditMapeditMapeditMapeditMapeditMap")			if (!trgtEdit.contains(drawArea)) trgtEdit.addChild(drawArea);			if (!trgtEdit.contains(drawCnt)) trgtEdit.addChild(drawCnt);		}		public function editMap(str) {			setEditMap();			var xmlMap:XMLDocument = new XMLDocument();			xmlMap.ignoreWhite = true;			xmlMap.parseXML(str);			for (var a=0;a<xmlMap.childNodes[0].childNodes[0].childNodes.length;a++) {				shapesA[a] = new Array();				handlesAcnt.push(new Sprite());				drawCnt.addChild(handlesAcnt[a]);				var forma = xmlMap.childNodes[0].childNodes[0].childNodes[a].attributes.d.substring(1).split("Q");				for (var b=0;b<forma.length;b++) {					forma[b] = forma[b].split(",");					trace(a+"-"+b+" "+forma[b][0]+" "+forma[b][1]+" "+forma[b][2]+" "+forma[b][3])					var punto = new Array((forma[b][2] ? forma[b][2] : forma[b][0]),(forma[b][3] ? forma[b][3] : forma[b][1]),forma[b][0],forma[b][1])					var tt = new MapPoint(punto,a,b, updatePath, false)					handlesAcnt[a].addChildAt(tt,b);					shapesA[a].push(punto);				}				currentShape = a;				updateCurrent()			}		}		function updateCurrent() {			trace("updateCurrent"+currentShape)			if (shapesAcnt[currentShape] is Shape) {				shapesAcnt[currentShape].graphics.clear();			} else {				shapesAcnt[currentShape] = new Shape();			}			shapesAcnt[currentShape].graphics.beginFill(0x0000FF,.5);			shapesAcnt[currentShape].graphics.moveTo(shapesA[currentShape][0][2], shapesA[currentShape][0][3]);			for (var a=1;a<shapesA[currentShape].length;a++) {				shapesAcnt[currentShape].graphics.curveTo(shapesA[currentShape][a][0], shapesA[currentShape][a][1], shapesA[currentShape][a][2], shapesA[currentShape][a][3]);			}			shapesAcnt[currentShape].graphics.curveTo(shapesA[currentShape][0][0], shapesA[currentShape][0][1], shapesA[currentShape][0][2], shapesA[currentShape][0][3]);			shapesAcnt[currentShape].graphics.endFill();			drawCnt.addChild(shapesAcnt[currentShape]); 		}	}}